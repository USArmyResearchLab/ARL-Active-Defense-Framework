#!/usr/bin/env python
# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4

import sys
from adf import *
from adf.canbus import Message
from adf.canbus.j1939 import J1939DecodeId, J1939EncodeId
import cantools.database
from cantools.database.errors import DecodeError


class DBCDecoder(Plugin):
    mask = 0x1fffffff  # default mask to pri,PGN,SA or for non-J1939 CAN
    strict = False  # good luck getting any DBC to load if this is set
    j1939 = True  # default is to decode j1939, appends spnNNN_ to signal names
    decode_choices = False  # you probably don't want text strings, you want values
    scaling = True  # you probably do want value conversion per the DBC
    prefix = ''  # appends prefix_ to message and signal names
    spn_tag = True

    def init(self):
        if self.prefix:
            # if prefix is specified add a _ to it.
            self.prefix = self.prefix+'_'
        self._dbc = cantools.database.load_file(
            self.dbc, strict=self.strict, frame_id_mask=self.mask)
        self._masks = {}
        self._spns = {}
        self._ranges = {}
        # if J1939 we need to wildcard the 0xfe "any" bytes in the arb ID because cantools doesn't do this for us
        for m in self._dbc.messages:
            # mask frame ID, then mask off 0xfe bytes
            mask = 0xffffffff
            mid = m.frame_id & self.mask  # apply default mask
            if self.j1939:
                if mid & 0x000000ff == 0xfe:  # SA is any, so mask it off
                    mask &= 0xffffff00
                    mid &= 0xffffff00
                if mid & 0x0000ff00 == 0xfe00:  # DA is any
                    mask &= 0xffff00ff
                    mid &= 0xffff00ff
            # store message by mask and masked id
            self._masks.setdefault(mask, {})[mid] = m
            for signal in m.signals:
                # if J1939, generate the spn tags
                if self.j1939 and signal.spn and self.spn_tag:
                    self._spns[signal.name] = 'spn%s_' % signal.spn
                self._ranges[signal.name] = (signal.minimum, signal.maximum)
        for k, v in self._masks.items():
            self.debug("mask %08x %d messages" % (k, len(v)))
        if type(self.pgns) is int:
            self.pgns = [self.pgns]
        self.debug("pgn filter: %s", self.pgns)

    def effect(self, info, msg):
        # decode the arb id
        try:
            if self.j1939:
                info.update(J1939DecodeId(msg))
                if self.pgns and info['PGN'] not in self.pgns:
                    return info, msg  # filtered out
            # decode more stuff here
            try:
                m = None
                for mask, messages in self._masks.items():
                    mid = msg.arbitration_id & self.mask & mask
                    if mid in messages:
                        m = messages[mid]
                        n = self.prefix+m.name
                        info['name'] = n
                        sigs = m.decode(
                            msg.data, self.decode_choices, self.scaling)
                        # if we have a prefix or an SPN tag for this signal, prepend them
                        info[n] = dict((self.prefix+self._spns.get(k, '')+k, v)
                                       for (k, v) in sigs.items())
                        try:  # try to add range amd valid info
                            info[n+'_range'] = dict((self.prefix+self._spns.get(
                                k, '')+k, self._ranges[k]) for k in sigs)
                            info[n+'_valid'] = dict((self.prefix+self._spns.get(
                                k, '')+k, (v >= self._ranges[k][0] and v <= self._ranges[k][1])) for k, v in sigs.items())
                        except:
                            pass  # we might not have range info
                        break  # got a match, stop
                if not m:
                    raise KeyError  # no match
            except KeyError:
                self.debug('%08x not in DBC' %
                           (msg.arbitration_id & self.mask))  # not in DBC
            except DecodeError as e:
                self.debug('%08x %s', (msg.arbitration_id & self.mask), e)
            except ValueError as e:
                self.debug('%08x %s', (msg.arbitration_id & self.mask), e)
            except Exception as e:
                self.warning('%08x %s', (msg.arbitration_id &
                             self.mask), m, exc_info=True)
        except Exception as e:
            self.debug(e)  # not J1939
        return info, msg


class DBCEncoder(DBCDecoder):
    padding = 0xff  # pad unused fields with 0xff

    def effect(self, info, msg):
        # regenerate the msg based on the values in info
        # info should contain 'name':X and a X:dict with k:v pairs generated by the DBCDecoder
        # msg arbitration_id will be re-encoded based on values in info
        # if we were not given a msg, create one
        if not msg:
            msg = Message(is_extended_id=self.j1939,
                          timestamp=info.get('ts', 0))
        # encode arb id
        if self.j1939:
            if self.pgns and info.get('PGN') not in self.pgns:
                return info, msg  # filtered out, same as DBCDecoder
            msg.arbitration_id = J1939EncodeId(**info)
        # set id if set in info
        else:
            msg.arbitration_id = int(info.get('id', msg.arbitration_id))
        # force ext id if > 11 bits.
        msg.is_extended_id = msg.is_extended_id or (msg.arbitration_id > 0x7ff)
        # get params and encode data
        name = info.get('name')
        if name:
            params = info.get(name)
            if params:
                # remove any spn tag or prefix, the DBC won't have them.
                if self.prefix:
                    name = name.replace(self.prefix, '', 1)
                    params = dict((k.replace(self.prefix, '', 1), v)
                                  for (k, v) in params.items())
                if self.j1939:
                    params = dict((k.split('_', 1)[1], v)
                                  for (k, v) in params.items())
                # encode based on DBC
                try:
                    d = self._dbc.encode_message(
                        name, params, scaling=self.scaling, strict=self.strict, padding=self.padding)
                    # set message data and length
                    msg.data, msg.dlc = d, len(d)
                except Exception as e:
                    self.warning(info, exc_info=True)  # log encoding errors
        return info, msg


def test(*args):
    import logging
    from adf.canbus.logger import Replay
    from pprint import pprint

    global DECODED_MSG
    DECODED_MSG = None

    class Dump(Plugin):
        def effect(self, info, msg):
            print(self.name, info['ts'], msg)
            pprint(info)
            global DECODED_MSG
            DECODED_MSG = msg
            if 'name' in info and info['name'] in info:
                # if we decoded, return an empty message, encoded will regenerate it
                return info, Message()
            else:
                return info, msg  # return unmodified message

    class Compare(Dump):
        def effect(self, info, msg):
            # verify encoded message = decoded message
            print(self.name, info['ts'], msg)
            try:
                assert (msg.data == DECODED_MSG.data and
                        msg.arbitration_id == DECODED_MSG.arbitration_id and
                        msg.dlc == DECODED_MSG.dlc and
                        msg.is_extended_id == DECODED_MSG.is_extended_id)
            except AssertionError:
                logging.warning('mismatch: %s\n%s\n%s', info, DECODED_MSG, msg)
            return info, None

    f = Framework()
    if len(args) > 2:
        pgns = [int(p) for p in args[2:]]
    else:
        pgns = None
    f.start_plugin(DBCDecoder, dbc=args[0], pgns=pgns)
    f.start_plugin(DBCEncoder, dbc=args[0], pgns=pgns)
    r = f.start_plugin(Replay)
    f.start_plugin(Dump, name='decoded')
    f.start_plugin(Compare, name='encoded')
    f.link_plugin('Replay', 'DBCDecoder')
    f.link_plugin('DBCDecoder', 'decoded')
    f.link_plugin('decoded', 'DBCEncoder')
    f.link_plugin('DBCEncoder', 'encoded')

    f.config_plugin('Replay', file=args[1], count=100)
    r.join()
    f.stop()


if __name__ == '__main__':
    import sys
    test(*sys.argv[1:])
